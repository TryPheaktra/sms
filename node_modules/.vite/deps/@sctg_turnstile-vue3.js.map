{
  "version": 3,
  "sources": ["../../@sctg/turnstile-vue3/src/Turnstile.vue", "../../@sctg/turnstile-vue3/index.ts"],
  "sourcesContent": ["<template>\n    <div ref=\"turnstile\"></div>\n</template>\n\n<script setup lang=\"ts\">\n/**\n * @component Turnstile\n * @description A Vue3 component that integrates Cloudflare's Turnstile CAPTCHA service.\n * This component handles the loading of the Turnstile script, rendering the widget, and\n * managing the widget's lifecycle events. It supports customization options like theme,\n * size, language, and more.\n * \n * @example\n * <template>\n *   <Turnstile \n *     site-key=\"your-site-key\" \n *     @complete=\"handleComplete\" \n *     theme=\"dark\" \n *     size=\"compact\"\n *   />\n * </template>\n */\nimport { ref, computed, onMounted, onBeforeUnmount } from 'vue';\n\n// The URL of the Turnstile API script.\nconst turnstileSrc = 'https://challenges.cloudflare.com/turnstile/v0/api.js';\n\n// The name of the function that will be called when the Turnstile script is loaded.\nconst turnstileLoadFunction = '_turnstileCb';\n\n// Ensure that TypeScript knows about the global variables.s\ndeclare global {\n    interface Window {\n        turnstile: Turnstile.Turnstile;\n        [turnstileLoadFunction]: () => void;\n    }\n}\n\n// The initial state of the Turnstile: 'unloaded' (not loaded), 'loading' (being loaded), or 'ready' (loaded).\nlet turnstileState = typeof window !== 'undefined' ? (window.turnstile !== undefined ? 'ready' : 'unloaded') : 'unloaded';\n\n/**\n * The promise that resolves when the Turnstile script is loaded.\n * @type {Object}\n * @property {Function} resolve - Function to resolve the promise\n * @property {Function} reject - Function to reject the promise\n */\nlet turnstileLoad: {\n    resolve: () => void;\n    reject: (value?: string) => void;\n};\n\n/**\n * Interface for the properties of the Turnstile component.\n * @interface TurnstileProps\n */\ninterface TurnstileProps {\n    /**\n     * The site key for the Turnstile widget.\n     * Obtained from the Cloudflare dashboard.\n     * @required\n     */\n    siteKey: string;\n    \n    /**\n     * The model value (initial value) for the Turnstile token.\n     * @required\n     */\n    modelValue: string;\n    \n    /**\n     * The interval (in ms) before the Turnstile widget is reset.\n     * @default 295000 (just under 5 minutes)\n     */\n    resetInterval?: number;\n    \n    /**\n     * The size of the Turnstile widget.\n     * @default 'normal'\n     */\n    size?: 'normal' | 'flexible' | 'compact';\n    \n    /**\n     * The theme of the Turnstile widget.\n     * @default 'auto'\n     */\n    theme?: 'light' | 'dark' | 'auto';\n    \n    /**\n     * The language of the Turnstile widget.\n     * Use a valid language code or 'auto' to detect automatically.\n     * @default 'auto'\n     */\n    language?: string;\n    \n    /**\n     * The action that the Turnstile widget is verifying.\n     * Can be used to identify different forms.\n     * @default ''\n     */\n    action?: string;\n    \n    /**\n     * The appearance of the Turnstile widget.\n     * @default 'always'\n     */\n    appearance?: 'always' | 'execute' | 'interaction-only';\n    \n    /**\n     * Whether to render the Turnstile widget when the component is mounted.\n     * @default true\n     */\n    renderOnMount?: boolean;\n}\n\n// Properties that can be passed to this component.\nconst props = withDefaults(defineProps<TurnstileProps>(), {\n    resetInterval: 295 * 1000,\n    size: 'normal',\n    theme: 'auto',\n    language: 'auto',\n    action: '',\n    appearance: 'always',\n    renderOnMount: true,\n});\n\n/**\n * Custom events emitted by this component.\n */\nconst emit = defineEmits<{\n    /**\n     * Update the model value with the new Turnstile token.\n     */\n    (e: 'update:modelValue', value: string): void;\n    /**\n     * The Turnstile widget has completed.\n     */\n    (e: 'complete'): void;\n    /**\n     * An error occurred.\n     */\n    (e: 'error', code: string): void;\n    /**\n     * The Turnstile widget is not supported.\n     */\n    (e: 'unsupported'): void;\n    /**\n     * The Turnstile widget has expired.\n     */\n    (e: 'expired'): void;\n    /**\n     * The Turnstile widget is about to become interactive.\n     */\n    (e: 'before-interactive'): void;\n    /**\n     * The Turnstile widget has become interactive.\n     */\n    (e: 'after-interactive'): void;\n}>();\n\n// A reference to the timeout for resetting the Turnstile widget.\nconst resetTimeout = ref<ReturnType<typeof setTimeout>>();\n\n// A reference to the ID of the Turnstile widget.\nconst widgetId = ref<string | undefined>();\n\n// A reference to the container element for the Turnstile widget.\nconst turnstile = ref<HTMLElement>();\n\n// The options for the Turnstile widget, computed from the props.\nconst turnstileOptions = computed(() => ({\n    sitekey: props.siteKey,\n    theme: props.theme,\n    language: props.language,\n    size: props.size,\n    // The callback function for when the user completes the challenge.\n    callback,\n    action: props.action,\n    appearance: props.appearance,\n    // The callback function for when an error occurs.\n    'error-callback': errorCallback,\n    // The callback function for when the widget expires.\n    'expired-callback': expiredCallback,\n    // The callback function for when the widget is not supported.\n    'unsupported-callback': unsupportedCallback,\n    // The callback function for when the widget is about to become interactive.\n    'before-interactive-callback': beforeInteractiveCallback,\n    // The callback function for when the widget becomes interactive.\n    'after-interactive-callback': afterInteractiveCallback,\n}));\n\n// Callback function for when the user completes the challenge.\nfunction afterInteractiveCallback() {\n    emit('after-interactive');\n}\n\n// Callback function for when the widget is about to become interactive.\nfunction beforeInteractiveCallback() {\n    emit('before-interactive');\n}\n\n// Callback function for when the widget expires.\nfunction expiredCallback() {\n    emit('expired');\n}\n\n// Callback function for when the widget is not supported.\nfunction unsupportedCallback() {\n    emit('unsupported');\n}\n\n// Callback function for when an error occurs.\nfunction errorCallback(code: string) {\n    emit('error', code);\n}\n\n// Callback function for when the user completes the challenge.\nfunction callback(token: string) {\n    emit('update:modelValue', token);\n    emit('complete');\n    // Start the reset timeout.\n    startResetTimeout();\n}\n\n// Reset the Turnstile widget.\nfunction reset() {\n    if (window.turnstile) {\n        // Clear the model value.\n        emit('update:modelValue', '');\n        // Reset the Turnstile widget.\n        window.turnstile.reset();\n    }\n}\n\n// Remove the Turnstile widget.\nfunction remove() {\n    if (widgetId.value) {\n        // Remove the Turnstile widget.\n        window.turnstile.remove(widgetId.value);\n        // Clear the widget ID.\n        widgetId.value = undefined;\n    }\n}\n\n// Render the Turnstile widget.\nfunction render() {\n    if (turnstile.value) {\n        // Render the Turnstile widget.\n        widgetId.value = window.turnstile.render(turnstile.value, turnstileOptions.value);\n    }\n}\n\n// Start the reset timeout.\nfunction startResetTimeout() {\n    // Validate and sanitizep rops.resetInterval\n    const resetInterval = Math.max(0, Math.min(props.resetInterval, 300 * 1000));\n    // Clear any existing timeout.\n    resetTimeout.value = setTimeout(() => {\n        // Reset the Turnstile widget.\n        reset();\n    }, resetInterval);\n}\n\n// When the component is mounted...\nonMounted(async () => {\n    // Validate and sanitize props (e.g., siteKey)\n    const validSiteKeyRegex = /^[a-zA-Z0-9_]{10,}$/;\n    if (!validSiteKeyRegex.test(props.siteKey)) {\n        throw new Error('Invalid site key');\n    }\n\n    // Create a promise that resolves when the Turnstile script is loaded.\n    const turnstileLoadPromise = new Promise<void>((resolve, reject) => {\n        turnstileLoad = { resolve, reject };\n        if (turnstileState === 'ready') resolve();\n    });\n\n    // Define the callback function for when the Turnstile script is loaded.\n    window[turnstileLoadFunction] = () => {\n        // Resolve the promise.\n        turnstileLoad.resolve();\n        // Update the Turnstile state.\n        turnstileState = 'ready';\n    };\n\n    // Ensure that the Turnstile script is loaded.\n    const ensureTurnstile = () => {\n        if (turnstileState === 'unloaded') {\n            // Update the Turnstile state.\n            turnstileState = 'loading';\n            // Create the script element.\n            const url = `${turnstileSrc}?onload=${turnstileLoadFunction}&render=explicit`;\n            const script = document.createElement('script');\n            script.src = url;\n            script.async = true;\n            // Handle errors.\n            script.addEventListener('error', () => {\n                turnstileLoad.reject('Failed to load Turnstile.');\n            });\n            // Append the script element.\n            document.head.appendChild(script);\n        }\n        // Return the promise.\n        return turnstileLoadPromise;\n    };\n\n    // Wait for the Turnstile script to be loaded.\n    await ensureTurnstile();\n\n    // If renderOnMount is true, render the Turnstile widget.\n    if (props.renderOnMount) {\n        render();\n    }\n});\n\n// When the component is about to be unmounted...\nonBeforeUnmount(() => {\n    // Remove the Turnstile widget.\n    remove();\n    // Clear the reset timeout.\n    if (resetTimeout.value) {\n        clearTimeout(resetTimeout.value);\n    }\n});\n</script>", "import Turnstile from \"./src/Turnstile.vue\";\n\n/**\n * Verifies a Turnstile captcha token by sending it to Cloudflare's verification endpoint.\n * \n * This function is designed to work in both Node.js and Cloudflare Worker environments.\n * It follows Cloudflare's verification process documented at:\n * https://developers.cloudflare.com/turnstile/get-started/server-side-validation/\n * \n * @param turnstileSecret - Cloudflare Turnstile secret key from your Cloudflare dashboard\n * @param token - The captcha token received from the client-side widget\n * @param connectingIP - The IP address of the connecting client (for additional security validation)\n * \n * @returns A Promise that resolves to a CaptchaVerifyResponse object\n * \n * @example\n * // Using in a Node.js Express server\n * app.post('/verify-captcha', async (req, res) => {\n *   const { token } = req.body;\n *   const secret = process.env.TURNSTILE_SECRET;\n *   \n *   try {\n *     const result = await verifyCaptcha(secret, token, req.ip);\n *     if (result.success) {\n *       res.json({ verified: true });\n *     } else {\n *       res.status(400).json({ verified: false, errors: result['error-codes'] });\n *     }\n *   } catch (error) {\n *     res.status(500).json({ error: 'Verification failed' });\n *   }\n * });\n * \n * @example\n * // Using in a Cloudflare Worker\n * async function handleRequest(request) {\n *   const { token } = await request.json();\n *   const secret = TURNSTILE_SECRET; // Environment variable in Cloudflare Workers\n *   \n *   try {\n *     const result = await verifyCaptcha(secret, token, request.headers.get('CF-Connecting-IP'));\n *     if (result.success) {\n *       return new Response(JSON.stringify({ verified: true }), {\n *         headers: { 'Content-Type': 'application/json' }\n *       });\n *     } else {\n *       return new Response(JSON.stringify({ verified: false, errors: result['error-codes'] }), {\n *         status: 400,\n *         headers: { 'Content-Type': 'application/json' }\n *       });\n *     }\n *   } catch (error) {\n *     return new Response(JSON.stringify({ error: 'Verification failed' }), {\n *       status: 500,\n *       headers: { 'Content-Type': 'application/json' }\n *     });\n *   }\n * }\n */\nasync function verifyCaptcha(turnstileSecret: string, token: string, connectingIP: string) {\n    // Validate the token by calling the\n    // \"/siteverify\" API endpoint.\n    let formData = new FormData();\n    formData.append(\"secret\", turnstileSecret);\n    formData.append(\"response\", token);\n    formData.append(\"remoteip\", connectingIP);\n\n    const url = \"https://challenges.cloudflare.com/turnstile/v0/siteverify\";\n    const result = await fetch(url, {\n      body: formData,\n      method: \"POST\",\n    });\n\n    const outcome = await result.json() as any;\n    if (outcome.success) { }\n    return {\n      success: outcome.success,\n      challenge_ts: \"\",\n      hostname: \"\",\n    } as CaptchaVerifyResponse\n  }\n\n/**\n * Response format from the Cloudflare Turnstile verification API.\n * This format is compatible with hCaptcha's response format for easier migration.\n * \n * @see https://developers.cloudflare.com/turnstile/get-started/server-side-validation/#response-object\n */\nexport type CaptchaVerifyResponse = {\n    /** Whether the verification was successful */\n    success: boolean \n    \n    /** Timestamp of the challenge (ISO format yyyy-MM-dd'T'HH:mm:ssZZ) */\n    challenge_ts: string \n    \n    /** The hostname of the site where the challenge was solved */\n    hostname: string \n    \n    /** Optional: whether the response will be credited */\n    credit?: boolean \n    \n    /** Optional: any error codes */\n    'error-codes'?: CaptchaVerifyError \n    \n    /** ENTERPRISE feature: a score denoting malicious activity */\n    score?: number \n    \n    /** ENTERPRISE feature: reason(s) for score */\n    score_reason?: string[] \n  }\nexport type CaptchaVerifyError = string | string[]\nexport { verifyCaptcha, Turnstile };"],
  "mappings": "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",
  "names": ["script"]
}
