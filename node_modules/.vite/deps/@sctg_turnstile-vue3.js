import {
  computed,
  createElementBlock,
  defineComponent,
  onBeforeUnmount,
  onMounted,
  openBlock,
  ref
} from "./chunk-DAESH65R.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@sctg/turnstile-vue3/dist/index.js
var turnstileSrc = "https://challenges.cloudflare.com/turnstile/v0/api.js";
var turnstileLoadFunction = "_turnstileCb";
var script = defineComponent({
  __name: "Turnstile",
  props: {
    siteKey: { type: String, required: true },
    modelValue: { type: String, required: true },
    resetInterval: { type: Number, required: false, default: 295 * 1e3 },
    size: { type: String, required: false, default: "normal" },
    theme: { type: String, required: false, default: "auto" },
    language: { type: String, required: false, default: "auto" },
    action: { type: String, required: false, default: "" },
    appearance: { type: String, required: false, default: "always" },
    renderOnMount: { type: Boolean, required: false, default: true }
  },
  emits: ["update:modelValue", "complete", "error", "unsupported", "expired", "before-interactive", "after-interactive"],
  setup(__props, { emit: __emit }) {
    let turnstileState = typeof window !== "undefined" ? window.turnstile !== void 0 ? "ready" : "unloaded" : "unloaded";
    let turnstileLoad;
    const props = __props;
    const emit = __emit;
    const resetTimeout = ref();
    const widgetId = ref();
    const turnstile = ref();
    const turnstileOptions = computed(() => ({
      sitekey: props.siteKey,
      theme: props.theme,
      language: props.language,
      size: props.size,
      // The callback function for when the user completes the challenge.
      callback,
      action: props.action,
      appearance: props.appearance,
      // The callback function for when an error occurs.
      "error-callback": errorCallback,
      // The callback function for when the widget expires.
      "expired-callback": expiredCallback,
      // The callback function for when the widget is not supported.
      "unsupported-callback": unsupportedCallback,
      // The callback function for when the widget is about to become interactive.
      "before-interactive-callback": beforeInteractiveCallback,
      // The callback function for when the widget becomes interactive.
      "after-interactive-callback": afterInteractiveCallback
    }));
    function afterInteractiveCallback() {
      emit("after-interactive");
    }
    function beforeInteractiveCallback() {
      emit("before-interactive");
    }
    function expiredCallback() {
      emit("expired");
    }
    function unsupportedCallback() {
      emit("unsupported");
    }
    function errorCallback(code) {
      emit("error", code);
    }
    function callback(token) {
      emit("update:modelValue", token);
      emit("complete");
      startResetTimeout();
    }
    function reset() {
      if (window.turnstile) {
        emit("update:modelValue", "");
        window.turnstile.reset();
      }
    }
    function remove() {
      if (widgetId.value) {
        window.turnstile.remove(widgetId.value);
        widgetId.value = void 0;
      }
    }
    function render() {
      if (turnstile.value) {
        widgetId.value = window.turnstile.render(turnstile.value, turnstileOptions.value);
      }
    }
    function startResetTimeout() {
      const resetInterval = Math.max(0, Math.min(props.resetInterval, 300 * 1e3));
      resetTimeout.value = setTimeout(() => {
        reset();
      }, resetInterval);
    }
    onMounted(async () => {
      const validSiteKeyRegex = /^[a-zA-Z0-9_]{10,}$/;
      if (!validSiteKeyRegex.test(props.siteKey)) {
        throw new Error("Invalid site key");
      }
      const turnstileLoadPromise = new Promise((resolve, reject) => {
        turnstileLoad = { resolve, reject };
        if (turnstileState === "ready")
          resolve();
      });
      window[turnstileLoadFunction] = () => {
        turnstileLoad.resolve();
        turnstileState = "ready";
      };
      const ensureTurnstile = () => {
        if (turnstileState === "unloaded") {
          turnstileState = "loading";
          const url = `${turnstileSrc}?onload=${turnstileLoadFunction}&render=explicit`;
          const script2 = document.createElement("script");
          script2.src = url;
          script2.async = true;
          script2.addEventListener("error", () => {
            turnstileLoad.reject("Failed to load Turnstile.");
          });
          document.head.appendChild(script2);
        }
        return turnstileLoadPromise;
      };
      await ensureTurnstile();
      if (props.renderOnMount) {
        render();
      }
    });
    onBeforeUnmount(() => {
      remove();
      if (resetTimeout.value) {
        clearTimeout(resetTimeout.value);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(
        "div",
        {
          ref_key: "turnstile",
          ref: turnstile
        },
        null,
        512
        /* NEED_PATCH */
      );
    };
  }
});
script.__file = "src/Turnstile.vue";
async function verifyCaptcha(turnstileSecret, token, connectingIP) {
  let formData = new FormData();
  formData.append("secret", turnstileSecret);
  formData.append("response", token);
  formData.append("remoteip", connectingIP);
  const url = "https://challenges.cloudflare.com/turnstile/v0/siteverify";
  const result = await fetch(url, {
    body: formData,
    method: "POST"
  });
  const outcome = await result.json();
  if (outcome.success) ;
  return {
    success: outcome.success,
    challenge_ts: "",
    hostname: ""
  };
}
export {
  script as Turnstile,
  verifyCaptcha
};
//# sourceMappingURL=@sctg_turnstile-vue3.js.map
