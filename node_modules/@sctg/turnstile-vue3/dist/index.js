import { defineComponent, ref, computed, onMounted, onBeforeUnmount, createElementBlock, openBlock } from 'vue';

// The URL of the Turnstile API script.
const turnstileSrc = 'https://challenges.cloudflare.com/turnstile/v0/api.js';
// The name of the function that will be called when the Turnstile script is loaded.
const turnstileLoadFunction = '_turnstileCb';
// Properties that can be passed to this component.
var script = /*@__PURE__*/ defineComponent({
    __name: 'Turnstile',
    props: {
        siteKey: { type: String, required: true },
        modelValue: { type: String, required: true },
        resetInterval: { type: Number, required: false, default: 295 * 1000 },
        size: { type: String, required: false, default: 'normal' },
        theme: { type: String, required: false, default: 'auto' },
        language: { type: String, required: false, default: 'auto' },
        action: { type: String, required: false, default: '' },
        appearance: { type: String, required: false, default: 'always' },
        renderOnMount: { type: Boolean, required: false, default: true }
    },
    emits: ["update:modelValue", "complete", "error", "unsupported", "expired", "before-interactive", "after-interactive"],
    setup(__props, { emit: __emit }) {
        /**
         * @component Turnstile
         * @description A Vue3 component that integrates Cloudflare's Turnstile CAPTCHA service.
         * This component handles the loading of the Turnstile script, rendering the widget, and
         * managing the widget's lifecycle events. It supports customization options like theme,
         * size, language, and more.
         *
         * @example
         * <template>
         *   <Turnstile
         *     site-key="your-site-key"
         *     @complete="handleComplete"
         *     theme="dark"
         *     size="compact"
         *   />
         * </template>
         */
        let turnstileState = typeof window !== 'undefined' ? (window.turnstile !== undefined ? 'ready' : 'unloaded') : 'unloaded';
        /**
         * The promise that resolves when the Turnstile script is loaded.
         * @type {Object}
         * @property {Function} resolve - Function to resolve the promise
         * @property {Function} reject - Function to reject the promise
         */
        let turnstileLoad;
        /**
         * Interface for the properties of the Turnstile component.
         * @interface TurnstileProps
         */
        const props = __props;
        /**
         * Custom events emitted by this component.
         */
        const emit = __emit;
        // A reference to the timeout for resetting the Turnstile widget.
        const resetTimeout = ref();
        // A reference to the ID of the Turnstile widget.
        const widgetId = ref();
        // A reference to the container element for the Turnstile widget.
        const turnstile = ref();
        // The options for the Turnstile widget, computed from the props.
        const turnstileOptions = computed(() => ({
            sitekey: props.siteKey,
            theme: props.theme,
            language: props.language,
            size: props.size,
            // The callback function for when the user completes the challenge.
            callback,
            action: props.action,
            appearance: props.appearance,
            // The callback function for when an error occurs.
            'error-callback': errorCallback,
            // The callback function for when the widget expires.
            'expired-callback': expiredCallback,
            // The callback function for when the widget is not supported.
            'unsupported-callback': unsupportedCallback,
            // The callback function for when the widget is about to become interactive.
            'before-interactive-callback': beforeInteractiveCallback,
            // The callback function for when the widget becomes interactive.
            'after-interactive-callback': afterInteractiveCallback,
        }));
        // Callback function for when the user completes the challenge.
        function afterInteractiveCallback() {
            emit('after-interactive');
        }
        // Callback function for when the widget is about to become interactive.
        function beforeInteractiveCallback() {
            emit('before-interactive');
        }
        // Callback function for when the widget expires.
        function expiredCallback() {
            emit('expired');
        }
        // Callback function for when the widget is not supported.
        function unsupportedCallback() {
            emit('unsupported');
        }
        // Callback function for when an error occurs.
        function errorCallback(code) {
            emit('error', code);
        }
        // Callback function for when the user completes the challenge.
        function callback(token) {
            emit('update:modelValue', token);
            emit('complete');
            // Start the reset timeout.
            startResetTimeout();
        }
        // Reset the Turnstile widget.
        function reset() {
            if (window.turnstile) {
                // Clear the model value.
                emit('update:modelValue', '');
                // Reset the Turnstile widget.
                window.turnstile.reset();
            }
        }
        // Remove the Turnstile widget.
        function remove() {
            if (widgetId.value) {
                // Remove the Turnstile widget.
                window.turnstile.remove(widgetId.value);
                // Clear the widget ID.
                widgetId.value = undefined;
            }
        }
        // Render the Turnstile widget.
        function render() {
            if (turnstile.value) {
                // Render the Turnstile widget.
                widgetId.value = window.turnstile.render(turnstile.value, turnstileOptions.value);
            }
        }
        // Start the reset timeout.
        function startResetTimeout() {
            // Validate and sanitizep rops.resetInterval
            const resetInterval = Math.max(0, Math.min(props.resetInterval, 300 * 1000));
            // Clear any existing timeout.
            resetTimeout.value = setTimeout(() => {
                // Reset the Turnstile widget.
                reset();
            }, resetInterval);
        }
        // When the component is mounted...
        onMounted(async () => {
            // Validate and sanitize props (e.g., siteKey)
            const validSiteKeyRegex = /^[a-zA-Z0-9_]{10,}$/;
            if (!validSiteKeyRegex.test(props.siteKey)) {
                throw new Error('Invalid site key');
            }
            // Create a promise that resolves when the Turnstile script is loaded.
            const turnstileLoadPromise = new Promise((resolve, reject) => {
                turnstileLoad = { resolve, reject };
                if (turnstileState === 'ready')
                    resolve();
            });
            // Define the callback function for when the Turnstile script is loaded.
            window[turnstileLoadFunction] = () => {
                // Resolve the promise.
                turnstileLoad.resolve();
                // Update the Turnstile state.
                turnstileState = 'ready';
            };
            // Ensure that the Turnstile script is loaded.
            const ensureTurnstile = () => {
                if (turnstileState === 'unloaded') {
                    // Update the Turnstile state.
                    turnstileState = 'loading';
                    // Create the script element.
                    const url = `${turnstileSrc}?onload=${turnstileLoadFunction}&render=explicit`;
                    const script = document.createElement('script');
                    script.src = url;
                    script.async = true;
                    // Handle errors.
                    script.addEventListener('error', () => {
                        turnstileLoad.reject('Failed to load Turnstile.');
                    });
                    // Append the script element.
                    document.head.appendChild(script);
                }
                // Return the promise.
                return turnstileLoadPromise;
            };
            // Wait for the Turnstile script to be loaded.
            await ensureTurnstile();
            // If renderOnMount is true, render the Turnstile widget.
            if (props.renderOnMount) {
                render();
            }
        });
        // When the component is about to be unmounted...
        onBeforeUnmount(() => {
            // Remove the Turnstile widget.
            remove();
            // Clear the reset timeout.
            if (resetTimeout.value) {
                clearTimeout(resetTimeout.value);
            }
        });
        return (_ctx, _cache) => {
            return (openBlock(), createElementBlock("div", {
                ref_key: "turnstile",
                ref: turnstile
            }, null, 512 /* NEED_PATCH */));
        };
    }
});

script.__file = "src/Turnstile.vue";

/**
 * Verifies a Turnstile captcha token by sending it to Cloudflare's verification endpoint.
 *
 * This function is designed to work in both Node.js and Cloudflare Worker environments.
 * It follows Cloudflare's verification process documented at:
 * https://developers.cloudflare.com/turnstile/get-started/server-side-validation/
 *
 * @param turnstileSecret - Cloudflare Turnstile secret key from your Cloudflare dashboard
 * @param token - The captcha token received from the client-side widget
 * @param connectingIP - The IP address of the connecting client (for additional security validation)
 *
 * @returns A Promise that resolves to a CaptchaVerifyResponse object
 *
 * @example
 * // Using in a Node.js Express server
 * app.post('/verify-captcha', async (req, res) => {
 *   const { token } = req.body;
 *   const secret = process.env.TURNSTILE_SECRET;
 *
 *   try {
 *     const result = await verifyCaptcha(secret, token, req.ip);
 *     if (result.success) {
 *       res.json({ verified: true });
 *     } else {
 *       res.status(400).json({ verified: false, errors: result['error-codes'] });
 *     }
 *   } catch (error) {
 *     res.status(500).json({ error: 'Verification failed' });
 *   }
 * });
 *
 * @example
 * // Using in a Cloudflare Worker
 * async function handleRequest(request) {
 *   const { token } = await request.json();
 *   const secret = TURNSTILE_SECRET; // Environment variable in Cloudflare Workers
 *
 *   try {
 *     const result = await verifyCaptcha(secret, token, request.headers.get('CF-Connecting-IP'));
 *     if (result.success) {
 *       return new Response(JSON.stringify({ verified: true }), {
 *         headers: { 'Content-Type': 'application/json' }
 *       });
 *     } else {
 *       return new Response(JSON.stringify({ verified: false, errors: result['error-codes'] }), {
 *         status: 400,
 *         headers: { 'Content-Type': 'application/json' }
 *       });
 *     }
 *   } catch (error) {
 *     return new Response(JSON.stringify({ error: 'Verification failed' }), {
 *       status: 500,
 *       headers: { 'Content-Type': 'application/json' }
 *     });
 *   }
 * }
 */
async function verifyCaptcha(turnstileSecret, token, connectingIP) {
    // Validate the token by calling the
    // "/siteverify" API endpoint.
    let formData = new FormData();
    formData.append("secret", turnstileSecret);
    formData.append("response", token);
    formData.append("remoteip", connectingIP);
    const url = "https://challenges.cloudflare.com/turnstile/v0/siteverify";
    const result = await fetch(url, {
        body: formData,
        method: "POST",
    });
    const outcome = await result.json();
    if (outcome.success) ;
    return {
        success: outcome.success,
        challenge_ts: "",
        hostname: "",
    };
}

export { script as Turnstile, verifyCaptcha };
//# sourceMappingURL=index.js.map
